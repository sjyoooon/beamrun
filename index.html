<!doctype html>
<html lang="ko">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no"/>
  <title>ëŸ°ë‹¹ ëœë¤ + ê³µì¤‘ì¥ì• ë¬¼ + ê°€ì† + ê°€ë³€ ì í”„</title>
  <style>
    *{box-sizing:border-box}
    body{
      margin:0; background:#fff; height:100dvh; display:grid; place-items:center;
      font-family:system-ui,-apple-system,Segoe UI,Roboto,Noto Sans,Arial,Apple SD Gothic Neo,"ë§‘ì€ ê³ ë”•",sans-serif;
    }
    .wrap{position:relative; width:min(960px,100vw); padding:12px;}
    canvas{width:100%; height:auto; display:block; border:1px solid #ddd; background:#fff; touch-action:manipulation}
    .hud{pointer-events:none; position:absolute; top:12px; left:12px; right:12px; display:flex; justify-content:space-between; font-weight:700; font-variant-numeric:tabular-nums}
    .badge{background:rgba(255,255,255,.85); border:1px solid #eee; padding:6px 10px; border-radius:8px}
    #overlay{position:absolute; inset:0; display:none; place-items:center}
    button{appearance:none; border:0; padding:12px 16px; border-radius:10px; background:#111; color:#fff; font-weight:700; cursor:pointer; box-shadow:0 4px 12px rgba(0,0,0,.15)}
    button:active{transform:translateY(1px)}
  </style>
</head>
<body>
  <div class="wrap">
    <div class="hud">
      <div id="highScore" class="badge">ìµœê³ ì : 0</div>
      <div id="score" class="badge">ì ìˆ˜: 0</div>
    </div>
    <canvas id="game" width="900" height="260"></canvas>
    <div id="overlay"><button id="restartBtn">ì¬ì‹œì‘</button></div>
  </div>

  <script>
    // ===============================
    // ğŸ”§ CONFIG (ì—¬ê¸°ë§Œ ì†ëŒ€ë©´ ë¨)
    // ===============================
    const CONFIG = {
      GAME_WIDTH: 900,
      GAME_HEIGHT: 260,

      // ì§€ë©´/í”Œë ˆì´ì–´ í¬ê¸°
      GROUND_Y: 220,
      DINO_X: 60,
      DINO_WIDTH: 36,
      DINO_HEIGHT: 42,

      // ì´ë¯¸ì§€ ì„¸íŠ¸ (ëŸ° ì‹œì‘ ì‹œ 1íšŒ ëœë¤, ëŸ° ë™ì•ˆ ê³ ì •)
      DINO_PREFIX: "sloth",    DINO_IDS: ["01","02","03"],        // sloth01_a/b.png ...
      OBST_PREFIX: "prop",     OBST_IDS: ["01","02","03"],        // ì§€ìƒ: prop01.png ...
      AOBST_PREFIX: "propair", AOBST_IDS: ["01","02","03"],       // ê³µì¤‘: propair01.png ...
      BG_PREFIX: "bg",         BG_IDS: ["01","02","03"],          // ë°°ê²½: bg01.png ...
      CLOUD_PREFIX: "cloud",   CLOUD_IDS: ["01","02","03"],       // êµ¬ë¦„: cloud01.png ...

      // í´ë°± ìƒ‰/í¬ê¸°
      DINO_FALLBACK_COLOR: "#000000",
      OBST_FALLBACK_COLOR: "#e53935",
      BG_FALLBACK_COLOR: "#ffd54f",   BG_FALLBACK_SIZE: 80,   // ë…¸ë€ ì •ì‚¬ê°
      CLOUD_FALLBACK_COLOR: "#43a047",CLOUD_FALLBACK_SIZE: 24,// ì´ˆë¡ ì •ì‚¬ê°

      // ì ìˆ˜
      SCORE_PER_OBSTACLE: 10,
      HIGH_SCORE_KEY: "dino_highscore_v3",

      // ===== ìŠ¤í¬ë¡¤/ì†ë„ ê³¡ì„  (ì¥ì• ë¬¼/ë°°ê²½ ê³µí†µ ì‚¬ìš©) =====
      SPEED_BASE: 280,             // ê¸°ë³¸ ì†ë„(px/s)
      SPEED_MAX_MULT: 2.5,         // ìµœëŒ€ ë°°ì†(ê¸°ë³¸ì†ë„ì— ê³±í•´ì§)
      SPEED_RAMP_SECONDS: 60,      // ìµœëŒ€ë°°ì†ê¹Œì§€ ê±¸ë¦¬ëŠ” ì‹œê°„(ì´ˆ), ì„ í˜• ì¦ê°€

      // ===== ì¥ì• ë¬¼ ìŠ¤í° =====
      OBST_WIDTH: 30,
      OBST_HEIGHT: 50,
      OBST_MIN_GAP: 220,           // ë‹¤ìŒ ìŠ¤í°ê¹Œì§€ì˜ ìµœì†Œ/ìµœëŒ€ ê±°ë¦¬(px)
      OBST_MAX_GAP: 420,

      // ê³µì¤‘ì¥ì• ë¬¼(ì§€ìƒ ëŒ€ì‹  í™•ë¥ ë¡œ ë“±ì¥, ë™ì‹œì— ì•ˆ ë‚˜ì˜´)
      AIR_OBST_PROB: 35,           // 0~100 (%). ì´ í™•ë¥ ë¡œ ê³µì¤‘ì¥ì• ë¬¼ ì„ íƒ
      AIR_OBST_Y: 120,             // ìº”ë²„ìŠ¤ ê¸°ì¤€ top Y (í•­ìƒ ê°™ì€ ë†’ì´ë¡œ ë“±ì¥)
      // ê³µì¤‘ì¥ì• ë¬¼ë„ OBST_WIDTH/HEIGHTë¥¼ ì‚¬ìš©

      // ===== ë°°ê²½(3íƒ€ì¼ ìŠ¤í¬ë¡¤) =====
      BG_DRAW_WIDTH: 400,
      BG_DRAW_HEIGHT: 180,
      BG_Y: 40,
      BG_SCROLL_PARALLAX: 0.5,     // ìŠ¤í¬ë¡¤ì†ë„ ë¹„ìœ¨(ìŠ¤í¬ë¡¤ì†ë„ * ì´ ê°’)

      // ===== êµ¬ë¦„ =====
      CLOUD_WIDTH: 64,
      CLOUD_HEIGHT: 40,
      CLOUD_Y_MIN: 20,
      CLOUD_Y_MAX: 100,
      CLOUD_SPAWN_SEC_MIN: 1.2,
      CLOUD_SPAWN_SEC_MAX: 2.6,
      CLOUD_SPEED_MIN: 40,         // px/s (ê°œë³„ êµ¬ë¦„ ì†ë„)
      CLOUD_SPEED_MAX: 90,

      // ===== ì í”„(ê°€ë³€ ë†’ì´) =====
      JUMP_MIN_HEIGHT: 60,         // ìµœì†Œ ì í”„ ë†’ì´(px)
      JUMP_MAX_HEIGHT: 130,        // ìµœëŒ€ ì í”„ ë†’ì´(px)
      JUMP_MIN_HOLD: 0.08,         // ìµœì†Œ í™€ë“œ ì‹œê°„(ì´ˆ) ì´í•˜ë©´ ìµœì†Œ ë†’ì´
      JUMP_MAX_HOLD: 0.25,         // ìµœëŒ€ í™€ë“œ ì‹œê°„(ì´ˆ)ê¹Œì§€ ë¹„ë¡€ ê°€ì‚°
      GRAVITY: 1600                 // ì¤‘ë ¥(px/s^2)
    };

    // ===============================
    // ìº”ë²„ìŠ¤/ìƒíƒœ
    // ===============================
    const cvs = document.getElementById("game");
    const ctx = cvs.getContext("2d");
    const scoreEl = document.getElementById("score");
    const highScoreEl = document.getElementById("highScore");
    const overlay = document.getElementById("overlay");
    const restartBtn = document.getElementById("restartBtn");
    cvs.width = CONFIG.GAME_WIDTH; cvs.height = CONFIG.GAME_HEIGHT;

    const imageCache = new Map();
    function loadImageOnce(src){
      if(imageCache.has(src)) return imageCache.get(src);
      const e = { img:new Image(), ok:false, loaded:false };
      e.img.onload=()=>{e.ok=true; e.loaded=true;};
      e.img.onerror=()=>{e.ok=false; e.loaded=true;};
      e.img.src=src;
      imageCache.set(src,e);
      return e;
    }

    const pick = arr => arr[(Math.random()*arr.length)|0];
    const randInt = (a,b)=>Math.floor(Math.random()*(b-a+1))+a;
    const randFloat = (a,b)=>Math.random()*(b-a)+a;
    const clamp = (v,a,b)=>Math.max(a,Math.min(b,v));
    const rectsOverlap=(ax,ay,aw,ah,bx,by,bw,bh)=>ax<bx+bw&&ax+aw>bx&&ay<by+bh&&ay+ah>by;

    // ëŸ°ë‹¹ ê³ ì • ì„ íƒ
    let curDinoId=null, curGroundId=null, curAirId=null, curBgId=null, curCloudId=null;

    // ê²Œì„ ìƒíƒœ
    const state = {
      running:false, dead:false,
      runStartTime:0,        // ëŸ° ì‹œì‘ ì‹œê°(ms)
      lastTime:0,            // ì´ì „ í”„ë ˆì„(ms)
      animTime:0,            // dino ì• ë‹ˆ
      score:0, highScore:Number(localStorage.getItem(CONFIG.HIGH_SCORE_KEY)||0),
      distSinceLast:0
    };

    // í”Œë ˆì´ì–´
    const dino = {
      x:CONFIG.DINO_X, y:CONFIG.GROUND_Y-CONFIG.DINO_HEIGHT, w:CONFIG.DINO_WIDTH, h:CONFIG.DINO_HEIGHT,
      vy:0, onGround:true,
      holding:false, holdElapsed:0 // ì í”„ ê°€ë³€ í™€ë“œ
    };

    // ì¥ì• ë¬¼/êµ¬ë¦„/ë°°ê²½
    let obstacles=[]; // {x,y,w,h,scored?:bool, air?:bool}
    let clouds=[];    // {x,y,w,h,speed}
    let bgTiles=[];   // {x,y,w,h}
    let randGap=0;
    let cloudSpawnTimer=0, cloudSpawnNext=0;

    // ===== ê°€ë³€ ì í”„ ê³„ì‚° ë³´ì¡° =====
    // ì—ë„ˆì§€ ê´€ì : ë†’ì´ H ë‹¬ì„±ì— í•„ìš”í•œ ì´ˆê¸°ì†ë„ v0 = sqrt(2*g*H)
    const v0_min = Math.sqrt(2*CONFIG.GRAVITY*CONFIG.JUMP_MIN_HEIGHT);
    const v0_max = Math.sqrt(2*CONFIG.GRAVITY*CONFIG.JUMP_MAX_HEIGHT);
    const v0_add_total = Math.max(0, v0_max - v0_min); // í™€ë“œë¡œ ì¶”ê°€í•´ì¤„ ì´ Î”v
    const hold_window = Math.max(0.0001, CONFIG.JUMP_MAX_HOLD - CONFIG.JUMP_MIN_HOLD);

    function chooseRunAssets(){
      curDinoId   = pick(CONFIG.DINO_IDS);
      curGroundId = pick(CONFIG.OBST_IDS);
      curAirId    = pick(CONFIG.AOBST_IDS);
      curBgId     = pick(CONFIG.BG_IDS);
      curCloudId  = pick(CONFIG.CLOUD_IDS);
      // í”„ë¦¬ë¡œë“œ(ì‹¤íŒ¨í•´ë„ í´ë°± ì²˜ë¦¬)
      loadImageOnce(`${CONFIG.DINO_PREFIX}${curDinoId}_a.png`);
      loadImageOnce(`${CONFIG.DINO_PREFIX}${curDinoId}_b.png`);
      loadImageOnce(`${CONFIG.OBST_PREFIX}${curGroundId}.png`);
      loadImageOnce(`${CONFIG.AOBST_PREFIX}${curAirId}.png`);
      loadImageOnce(`${CONFIG.BG_PREFIX}${curBgId}.png`);
      loadImageOnce(`${CONFIG.CLOUD_PREFIX}${curCloudId}.png`);
    }

    function resetGame(){
      state.running=true; state.dead=false;
      state.runStartTime = performance.now();
      state.lastTime = state.runStartTime;
      state.animTime = 0; state.score=0; state.distSinceLast=0;

      dino.x=CONFIG.DINO_X; dino.y=CONFIG.GROUND_Y-dino.h;
      dino.vy=0; dino.onGround=true; dino.holding=false; dino.holdElapsed=0;

      chooseRunAssets();

      obstacles.length=0; clouds.length=0; bgTiles.length=0;
      randGap = randInt(CONFIG.OBST_MIN_GAP, CONFIG.OBST_MAX_GAP);

      // ë°°ê²½ íƒ€ì¼ 3ê°œ
      const w=CONFIG.BG_DRAW_WIDTH, h=CONFIG.BG_DRAW_HEIGHT, y=CONFIG.BG_Y;
      bgTiles.push({x:0,y,w,h},{x:w,y,w,h},{x:2*w,y,w,h});

      cloudSpawnTimer=0;
      cloudSpawnNext=randFloat(CONFIG.CLOUD_SPAWN_SEC_MIN, CONFIG.CLOUD_SPAWN_SEC_MAX);

      overlay.style.display="none";
      scoreEl.textContent=`ì ìˆ˜: ${state.score}`;
      highScoreEl.textContent=`ìµœê³ ì : ${state.highScore}`;
      requestAnimationFrame(loop);
    }

    function gameOver(){
      state.dead=true; state.running=false;
      if(state.score>state.highScore){
        state.highScore=state.score;
        localStorage.setItem(CONFIG.HIGH_SCORE_KEY, String(state.highScore));
      }
      highScoreEl.textContent=`ìµœê³ ì : ${state.highScore}`;
      overlay.style.display="grid";
    }

    // í˜„ì¬ ìŠ¤í¬ë¡¤ ì†ë„(ê°€ì† ê³¡ì„ )
    function currentScrollSpeed(nowMs){
      const t = Math.max(0, (nowMs - state.runStartTime)/1000); // ì´ˆ
      const r = CONFIG.SPEED_RAMP_SECONDS>0 ? clamp(t/CONFIG.SPEED_RAMP_SECONDS,0,1) : 1;
      const mult = 1 + (CONFIG.SPEED_MAX_MULT-1)*r;
      return CONFIG.SPEED_BASE * mult;
    }

    // ìŠ¤í°
    function trySpawnObstacle(speed){
      if(state.distSinceLast < randGap) return;

      const w=CONFIG.OBST_WIDTH, h=CONFIG.OBST_HEIGHT;
      // ê³µì¤‘ í™•ë¥ 
      const useAir = (randInt(1,100) <= CONFIG.AIR_OBST_PROB);

      if(useAir){
        obstacles.push({ x: CONFIG.GAME_WIDTH + w, y: CONFIG.AIR_OBST_Y, w, h, scored:false, air:true });
      }else{
        obstacles.push({ x: CONFIG.GAME_WIDTH + w, y: CONFIG.GROUND_Y - h, w, h, scored:false, air:false });
      }
      state.distSinceLast = 0;
      randGap = randInt(CONFIG.OBST_MIN_GAP, CONFIG.OBST_MAX_GAP);
    }

    function trySpawnCloud(dt){
      cloudSpawnTimer += dt;
      if(cloudSpawnTimer < cloudSpawnNext) return;
      cloudSpawnTimer = 0;
      cloudSpawnNext = randFloat(CONFIG.CLOUD_SPAWN_SEC_MIN, CONFIG.CLOUD_SPAWN_SEC_MAX);
      const y = randInt(CONFIG.CLOUD_Y_MIN, CONFIG.CLOUD_Y_MAX);
      const speed = randFloat(CONFIG.CLOUD_SPEED_MIN, CONFIG.CLOUD_SPEED_MAX);
      clouds.push({ x: CONFIG.GAME_WIDTH + CONFIG.CLOUD_WIDTH, y, w:CONFIG.CLOUD_WIDTH, h:CONFIG.CLOUD_HEIGHT, speed });
    }

    // ì…ë ¥(í‚¤/í¬ì¸í„°)
    let pressActive=false;
    function onPressStart(){
      if(!state.running || state.dead) return;
      if(dino.onGround && !pressActive){
        pressActive=true; dino.holding=true; dino.holdElapsed=0;
        // ìµœì†Œ ì í”„ ì´ˆê¸°ì†ë„
        dino.vy = -v0_min;
        dino.onGround=false;
      }
    }
    function onPressEnd(){
      pressActive=false;
      dino.holding=false; // ì´í›„ ì¶”ê°€ ê°€ì† ì¤‘ì§€
    }

    window.addEventListener("keydown",e=>{
      if(e.code==="Space"||e.code==="ArrowUp"){ e.preventDefault(); onPressStart(); }
    },{passive:false});
    window.addEventListener("keyup",e=>{
      if(e.code==="Space"||e.code==="ArrowUp"){ e.preventDefault(); onPressEnd(); }
    },{passive:false});
    cvs.addEventListener("pointerdown",()=>onPressStart());
    window.addEventListener("pointerup",()=>onPressEnd());
    restartBtn.addEventListener("click", resetGame);

    // ë£¨í”„
    function loop(now){
      if(!state.running) return;
      const dt = Math.min(0.032, (now - state.lastTime)/1000);
      state.lastTime = now;
      state.animTime += dt;

      const speed = currentScrollSpeed(now); // ì¥ì• ë¬¼/ë°°ê²½ ê³µí†µ ì†ë„
      state.distSinceLast += speed * dt;

      // ì í”„ ê°€ë³€ í™€ë“œ: ìµœì†Œí™€ë“œ ì´í›„ë¶€í„° ìµœëŒ€í™€ë“œê¹Œì§€ ì¶”ê°€ Î”vë¥¼ ê· ë“± ê°€ì‚°
      if(dino.holding && !dino.onGround){
        dino.holdElapsed += dt;
        if(dino.holdElapsed > CONFIG.JUMP_MIN_HOLD){
          const over = Math.min(dino.holdElapsed, CONFIG.JUMP_MAX_HOLD) - CONFIG.JUMP_MIN_HOLD;
          const addRate = (hold_window>0) ? (v0_add_total / hold_window) : 0; // ì´ˆë‹¹ ì¶”ê°€ ì†ë„
          const dv = addRate * dt;
          // ìœ„ìª½ì´ ìŒìˆ˜ì´ë¯€ë¡œ vyì— ìŒìˆ˜ ë°©í–¥ìœ¼ë¡œ ë”í•´ì¤€ë‹¤
          dino.vy -= dv;
          if(dino.holdElapsed >= CONFIG.JUMP_MAX_HOLD){
            dino.holding=false; // ìµœëŒ€í™€ë“œ ë„ë‹¬ ì‹œ ì¤‘ì§€
          }
        }
      }

      // ì¤‘ë ¥
      dino.vy += CONFIG.GRAVITY * dt;
      dino.y += dino.vy * dt;
      // ì§€ë©´ ì¶©ëŒ
      const groundTop = CONFIG.GROUND_Y - dino.h;
      if(dino.y >= groundTop){
        dino.y = groundTop; dino.vy = 0; dino.onGround=true; dino.holding=false;
      }

      // ìŠ¤í°/ì—…ë°ì´íŠ¸
      trySpawnObstacle(speed);
      trySpawnCloud(dt);

      // ì¥ì• ë¬¼ ì´ë™/ì¶©ëŒ/ë“ì 
      for(let i=obstacles.length-1;i>=0;i--){
        const ob = obstacles[i];
        ob.x -= speed * dt;
        if(!ob.scored && ob.x + ob.w < dino.x){ ob.scored=true; state.score += CONFIG.SCORE_PER_OBSTACLE; scoreEl.textContent=`ì ìˆ˜: ${state.score}`; }
        if(rectsOverlap(dino.x,dino.y,dino.w,dino.h, ob.x,ob.y,ob.w,ob.h)){ gameOver(); render(); return; }
        if(ob.x + ob.w < -50) obstacles.splice(i,1);
      }

      // êµ¬ë¦„ ì´ë™
      for(let i=clouds.length-1;i>=0;i--){
        const c = clouds[i];
        c.x -= c.speed * dt;
        if(c.x + c.w < -10) clouds.splice(i,1);
      }

      // ë°°ê²½ ìŠ¤í¬ë¡¤(3íƒ€ì¼ ìˆœí™˜)
      const scroll = speed * CONFIG.BG_SCROLL_PARALLAX * dt;
      const tileW = CONFIG.BG_DRAW_WIDTH;
      let maxX=-Infinity;
      for(const t of bgTiles){ t.x -= scroll; if(t.x>maxX) maxX=t.x; }
      for(const t of bgTiles){ if(t.x + tileW < 0){ t.x = maxX + tileW; maxX = t.x; } }

      render();
      requestAnimationFrame(loop);
    }

    // ë Œë”
    function render(){
      ctx.clearRect(0,0,CONFIG.GAME_WIDTH,CONFIG.GAME_HEIGHT);
      // ë°°ê²½
      drawBackground();
      // êµ¬ë¦„
      for(const c of clouds) drawCloud(c);
      // ì§€ë©´ ë¼ì¸
      ctx.strokeStyle="#ddd"; ctx.beginPath();
      ctx.moveTo(0, CONFIG.GROUND_Y+0.5); ctx.lineTo(CONFIG.GAME_WIDTH, CONFIG.GROUND_Y+0.5); ctx.stroke();
      // ìºë¦­í„°
      drawDino();
      // ì¥ì• ë¬¼
      for(const ob of obstacles) drawObstacle(ob);
    }

    function drawBackground(){
      const key = `${CONFIG.BG_PREFIX}${curBgId}.png`;
      const e = imageCache.get(key) || loadImageOnce(key);
      for(const t of bgTiles){
        if(e.loaded && e.ok){ ctx.drawImage(e.img, t.x, t.y, t.w, t.h); }
        else{
          ctx.fillStyle = CONFIG.BG_FALLBACK_COLOR;
          const s=CONFIG.BG_FALLBACK_SIZE, cx=t.x+(t.w-s)/2, cy=t.y+(t.h-s)/2;
          ctx.fillRect(cx,cy,s,s);
        }
      }
    }

    function drawCloud(c){
      const key = `${CONFIG.CLOUD_PREFIX}${curCloudId}.png`;
      const e = imageCache.get(key) || loadImageOnce(key);
      if(e.loaded && e.ok){ ctx.drawImage(e.img, c.x, c.y, c.w, c.h); }
      else{
        ctx.fillStyle = CONFIG.CLOUD_FALLBACK_COLOR;
        const s=CONFIG.CLOUD_FALLBACK_SIZE, cx=c.x+(c.w-s)/2, cy=c.y+(c.h-s)/2;
        ctx.fillRect(cx,cy,s,s);
      }
    }

    function drawDino(){
      const frame = Math.floor(state.animTime*8)%2;
      const key = `${CONFIG.DINO_PREFIX}${curDinoId}_${frame===0?"a":"b"}.png`;
      const e = imageCache.get(key) || loadImageOnce(key);
      if(e.loaded && e.ok){ ctx.drawImage(e.img, dino.x, dino.y, dino.w, dino.h); }
      else{ ctx.fillStyle=CONFIG.DINO_FALLBACK_COLOR; ctx.fillRect(dino.x,dino.y,dino.w,dino.h); }
    }

    function drawObstacle(ob){
      const isAir = !!ob.air;
      const key = isAir ? `${CONFIG.AOBST_PREFIX}${curAirId}.png` : `${CONFIG.OBST_PREFIX}${curGroundId}.png`;
      const e = imageCache.get(key) || loadImageOnce(key);
      if(e.loaded && e.ok){ ctx.drawImage(e.img, ob.x, ob.y, ob.w, ob.h); }
      else{ ctx.fillStyle=CONFIG.OBST_FALLBACK_COLOR; ctx.fillRect(ob.x,ob.y,ob.w,ob.h); }
    }

    // ì‹œì‘
    highScoreEl.textContent=`ìµœê³ ì : ${state.highScore}`;
    resetGame();
  </script>
</body>
</html>